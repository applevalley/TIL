# 6. SQL 고급

### MySQL의 데이터 형식

- MySQL에서 지원하는 데이터 형식의 종류

  - 30개 가량 되는데, 이걸 다 외울 필요는 없다. 

  - 숫자 데이터 형식

    - 정수, 실수 등의 수를 표현한다.

    - | 데이터 형식              | 바이트 수 | 숫자 범위                 | 설명                                                 |
      | ------------------------ | --------- | ------------------------- | ---------------------------------------------------- |
      | BIT(N)                   | N / 8     |                           | 1 ~ 64bit 표현. b'0000'식 표현                       |
      | TINYINT                  | 1         | -128 ~ 127                | 정수                                                 |
      | **SMALLINT**             | 2         | -32,768 ~ 32,767          | 정수                                                 |
      | MEDIUMINT                | 3         | -8,338,608 ~ 8,338,607    | 정수                                                 |
      | **INT**<br />INTEGER     | 4         | 약 -21억 ~ 21억           | 정수                                                 |
      | **BIGINT**               | 8         | 약 -900경 ~ 900경         | 정수                                                 |
      | **FLOAT**                | 4         | -3.40E + 38 ~ -1.17E - 38 | 소수점 아래 7자리까지                                |
      | DOUBLE<br />REAL         | 8         | -1.22E-308 ~1.79E + 308   | 소수점 아래 15자리까지                               |
      | **DECIMAL**<br />NUMERIC | 5 ~ 17    | -10^38 + 1 ~ 10^38 - 1    | 전체 자릿수와 소수점 <br />이하 자릿수를 가진 숫자형 |

    - DECIMAL 형식은 정확한 수치를 저장하고(decimal(10, 3)은 전체 자릿수를 10자리고, 그 중 소수점 이하를 3자리로), FLOAT, DOUBLE은 근사치의 숫자를 저장한다. 근사치의 수를 저장하는 대신 상당히 큰 숫자도 저장할 수 있다.

    - 소수점이 들어간 실수를 저장하려면 가급적 DECIMAL형식으로 하는 것이 좋다.

    - MySQL은 **부호가 없는** 정수를 지원한다. 부호가 없다는 것은 음수 없이 0 이상의 수들로 표현할 수 있게 하는데, TINYINT의 경우 -128 ~ 127의 범위가 0 ~ 255로 원래의 범위가 0부터로 옮겨간다. 

    - 이렇게 부호가 없는 정수를 지정할 때는 데이터 형식 뒤에 `UNSIGNED`예약어를 붙여주면 된다.

    - 데이터 형식이 왜 중요한가?

      - 데이터 형식을 아무렇게나 하면 불필요한 공간 차지로 인해 전반적인 속도 저하를 불러온다.
      - 나이나, 키를 저장하기 위해 INT형을 사용한다고 가정해보자. 기껏해야 100, 200정도도 되지 않는 데이터에 억단위의 범위를 표현하는 INT를 쓴다는 것은 매우 큰 낭비이다. 이런 데이터가 셀 수 없을 정도로 쌓인다면 필연적으로 성능의 저하가 생긴다.
      - 나이같은 경우 아무리 커봐야 SMALLINT의 범위에서 해결이 된다. 더 생각해보면 UNSIGNED 예약어를 TINYINT형에 붙여 0 ~ 255의 범위를 만든다면 또 한 바이트를 절감할 수 있게 되는것이다.

  - 문자 데이터 형식

    - | 데이터 형식    | 바이트 수         | 설명                                                         |
      | -------------- | ----------------- | ------------------------------------------------------------ |
      | **CHAR**(n)    | 1 ~ 255           | **고정**길이 문자 n을 1 ~ 255까지 지정함.<br />그냥 CHAR만 쓰면 CHAR(1)과 같다. |
      | **VARCHAR**(n) | 1 ~ 65,535        | **가변**길이 문자 n을 1 ~ 65535까지 지정함.<br />그냥 VARCHAR만 쓰면 VARCHAR(1)과 같다. |
      | BINARY(n)      | 1 ~ 255           | 고정길이의 이진 데이터 값                                    |
      | VARBINARY(n)   | 1 ~ 255           | 가변길이의 이진 데이터 값                                    |
      | TINYTEXT       | 1 ~ 255           | 255 크기의 TEXT 데이터 값                                    |
      | TEXT           | 1 ~ 65,535        | N 크기의 TEXT 데이터 값                                      |
      | MEDIUMTEXT     | 1 ~ 16,777,215    | 16777215 크기의 TEXT 데이터 값                               |
      | **LONGTEXT**   | 1 ~ 4,294,967,295 | 최대 4GB 크기의 TEXT 데이터 값                               |
      | TINYBLOB       | 1 ~255            | 255 크기의 BLOB 데이터 값                                    |
      | BLOB           | 1 ~ 65,535        | N 크기의 BLOB 데이터 값                                      |
      | MEDIUMBLOB     | 1 ~ 16,777,215    | 16777215 크기의 BLOB 데이터 값                               |
      | **LONGBLOB**   | 1 ~ 4,294,967,295 | 최대 4GB 크기의 BLOB 데이터 값                               |
      | ENUM(값)       | 1 OR 2            | 최대 65535개의 열거형 데이터 값                              |
      | SET(값)        | 1, 2, 3, 4, 8     | 최대 64개의 서로 다른 데이터 값                              |

    - CHAR 형식은 자릿수가 고정되어 있다. CHAR(30)에 두 글자만 저장하더라도 30자리를 확보한 이후 2자리를 사용하고 나머지는 낭비하게 되는 단점이 있다.

    - 반면 VARCHAR를 사용하면 똑같이 VARCHAR(30)에 두 글자를 저장하는 경우 2자리만 사용한다.

    - 그러나 CHAR형식을 사용하는 것이 INSERT / UPDATE 측면에서 성능이 좋게 나오는 편이다.

- 변수의 사용

  - SQL에서도 변수를 선언하고 사용할 수 있다.
  - `SET @변수 이름 = 변수의 값;` -- 변수 선언, 값 대입
  - `SELECT @변수 이름;` -- 변수 값 출력
  - 변수는 워크벤치를 재시작할 때까지는 유지되지만 닫았다가 재시작하면 소멸한다!
  - LIMIT에는 원칙적으로 변수를 사용할 수 없다. LIMIT X처럼 숫자를 넣는 것이 아닌  `LIMIT @변수`같은 형식이 불가능하다.
  - 그러나 PREPARE와 EXECUTE문을 활용한다면 변수 사용이 가능하다.
  - `PREPARE 쿼리 이름 FROM '쿼리문'`은 쿼리 이름에 쿼리문을 **준비만** 해두고서 바로 실행하지 않는다.
  - `EXECUTE 쿼리 이름`을 만나는 순간에 실행된다. EXECUTE는 `USING @변수`를 이용해서 쿼리문에서 `?`로 처리해둔 부분에 대입된다. 이것은 결국 `LIMIT @변수`로 쓴 것처럼 효과를 낸다.

```mysql
SET @myVar1 = 5;
SET @myVar2 = 3;
SET @myVar3 = 4.25;
SET @myVar4 = '가수 이름 ===> ';

SELECT @myVar1;
SELECT @myVar2 + @myVar3;
SELECT @myVar4, Name FROM usertbl WHERE height > 180;

SET @myVar1 = 3;
PREPARE myQuery
	FROM 'SELECT Name, height FROM usertbl ORDER BY height LIMIT ?';
EXECUTE myQuery USING @myVar1;
```

- 데이터 형식과 형 변환
  - 데이터 형식 변환 함수
    - 보통 CAST(), CONVERT() 함수가 사용된다. 형식이 다를 뿐 기능은 거의 비슷하다.
    - `CAST( expr AS 데이터 형식 [(길이)])`
    - `CONVERT( expr, 데이터 형식 [(길이)])`
    - `USE sqldb;
      SELECT AVG(amount) AS '평균 구매 개수' FROM buytbl;` 처럼 사용해 구매 테이블에서 평균 구매 개수를 구해볼 수 있다.
    - 실수로 나오는 경우 정수로 보기 위해 기존의 함수를 조금 수정해야 한다.
    - `SELECT CAST(AVG(amount) AS SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl;`
    - `SELECT CONVERT(AVG(amount), SIGNED INTEGER) AS '평균 구매 개수' FROM buytbl;`
    - SIGNED INTEGER를 통해 반올림된 정수의 결과를 볼 수 있다.
    - 날짜의 경우에도 여러 표현 방법이 있다.
    - `SELECT CAST('2021$01$09' AS DATE);`  
    - `SELECT CAST('2021/01/09' AS DATE);`  
    - `SELECT CAST('2021%01%09' AS DATE);`  
    - `SELECT CAST('2021@01@09' AS DATE);`  
    - 놀랍게도 4가지 전부 동일하다. 편한 것으로 사용하자.
  - 암시적 형 변환
    - 위에서 사용한 COST()나 CONVERT()를 사용하지 않고도 형이 변환되는 경우를 암시적 변환이라 한다.
    - `SELECT '100' + '200';` 문자와 문자를 더한다.(정수로 변환되어 처리)
    - `SELECT CONCAT('100', '200');` 문자와 문자를 연결한다.(**문자로 처리**)
    - `SELECT CONCAT(100, '200');` 정수와 문자를 연결(정수가 **문자로 변환**되어 처리)
    - `SELECT 1 > '2MEGA';` 정수인 2로 변환되어 비교
    - `SELECT 0 = 'MEGA2';` 문자는 0으로 변환 