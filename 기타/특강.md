```python
# 보통 코테에서 나오는 알고리즘 종류
# 다익스트라
# 슬라이딩 윈도우 / 투포인트
# 그리디 / 힙
# DP 기초
# BFS DFS 중급
# 유니온 파인드 / 최소신장트리 기초
# 그 외(해시 등...)

# 신입코테(NORMAL) < 코딩대회(HARD)

# 코테 회사
# 포털 (카카오가 제일 어려움)
# 제조 (삼성이 제일 어려움)
# 금융 (오히려 계열사가 어려운듯 / 포털이나 제조보다는 수월)
# SI (SDS가 제일 어렵다)
# ISP (웹 서비스에서는 프로그래머스에서 단체로)
# 정보보안
# 게임

# 세상의 많은 알고리즘
# 영상처리
# power on reset 처리
# 메모리 관리
# 프로세스 관리
# 언어인식
# 사물인식
# 데이터관리
# 등등..

# 우리가 잘해야 하는 알고리즘은 problem solving 분야..

# 실력을 빠르게 올리려면?
# 1. 기출 유형 분석, 반복 풀이
# 2. 알고리즘 하나씩 마스터하기
# 3. 고수들 코드 리뷰하면서 체화하기
# 4. 종만북
# 삼성 코테 한 문제정도 풀 정도 된다면 위의 트랙을 밟을만함

# 그러면? 잘 하려면?
# 1. 능숙함을 목표로
# 2. 마인드컨트롤
# 3. 풀기 전 항상 설계
# 4. 디버깅은 trace

# 능숙함의 차이
# 같은 문제를 풀더라도 얼만큼 능숙한가?의 차이
# 문제를 풀수 있나 없나보다는 얼마나 능숙하고, 수월하게 풀 수 있는가가 중요

# 같은 문제를 풀어도 소모되는 에너지가( 모름 << 이해함 <<<<<< 능숙함 <<<<<<<<<<<<< 고인물)
# 이해했다!하고 끝내면 안된다! 알거같다, 이해했다는 금방 도달할 수 있는 영역이다.
# 손에 붙을 때까지, 능숙하게 할 때까지 수십번이고 풀어봐야한다. (정말 눈 감고도 코드가 그려질 수준까지)

# 쉬운 문제? 어려운 문제?
# 중수 이상(삼성 코테 공략 가능)이 아니라면, 쉬운 문제를 더 우선적으로 많이 풀어보는게 좋다.
# 쉬운 문제여도 디버깅을 해야 할 경우가 있고, 문제 설계도 필요한 경우들이 있다.
# 그런 문제들로 연습을 하는 것이 좋다.
# 코테를 위한 기출 풀이는 차순위

# 추천 공부 방법 - daily 
# 매일 쉬운 문제를 두 문제씩
# 일단 난이도가 쉽던, 어렵던 매일 두 문제씩은 풀어보자.
# 보통 컨디션: 두 문제 / 컨디션 최고: 많이 풀어보자 ---> 기본기 숙달!!!
# 문제를 풀 때는 전역변수 마음껏 --> 현업에서는 하지 말아야 할 일

# 마인드 컨트롤
# 멘탈관리가 중요 - 주변 사람, 다른 사람들이 아니라 내가 생각하는 내 실력에 집중하기
# 실력이 만들어지면 결과가 잘 나올 것이고, 만들어지지 않았다면 결과도 잘 안나올거다
# ■■□□□□□□□□ ---> ■■■■■■■■□□ (현재 지점/ 만족할 나의 지점) 노력해서 빨리 수준을 올리자
# 시험 준비만큼 중요한 멘탈관리
# 시작부터 키보드 두두두두 때리는 사람들 / 끝나고 개쉬웠다고 입딜넣는 사람들에 영향받지 말 것
# 내 일을 차근차근 해나가자

# 언어는?
# 20년 전: java vs c++
# 현재: python vs c++
# 미래: ??? vs c++ ....?
# PS에서는 c++이 강점(수행 시간...)

# 사실은 언어는 문제가 아니다! 문제는 코딩 실력임. 실력이 낮으면, 무슨 언어던 소용없다
# 실력이 낮으면 언어를 바꾸려고 시도하는 경우가 많음(핑계대는것)

# 풀다가 막히면?
# 문제를 풀다 보면 느낌이 온다.
# 하씨 이거 못건드리겠는데? 뭐라는거야 대체? 풀이를 보면 알것도 같은데..
# 풀이 보지 말고 쉬운거 풀어라
# 일단 풀긴 풀었지만 최적화가 덜 되었는데.. 어떻게 하지?
# 조금 집중해서 고민하고, 풀이를 다 보지 말고 살짝만 보고, 다시 생각해보자!

# 그럼 기업에서 코테를 왜 보는가?
# 1. 코딩 기본기 / 문제 해결력
# 현업에서 신입이 프로그래밍을 잘 못하면 답답해함
# 반면 시원시원하면 가르치는 맛이 있음
# 2. 타 스펙 대비 경쟁력
# IQ(인적성)검사보다 유용 -> 확실히 토익성적, 해커톤-공모전 입상보다는 유용함

# Q&A
# 몇 문제 풀어야 코테 붙어요?
# 다 푸세요(n솔이 컷이라고 하면 n개를 풀 만큼만 공부할건가?)
# 주변 사람들은 너무 잘하는데 저는 구데기같아요 이건 능지차이인가요?
# 지능 차이는 사실입니다 하지만 어느 정도 수준에 도달하면 다들 엇비슷해집니다 더 노력하세요
# 종만북?
# 코테 합격하시고 입사 후에 보세요
# 알고리즘 스터디하면 좋은가요?
# 스터디가 성공하려면 사람 운이 좋아야 한다 -> 가급적 혼자 하세요
# problem solving이 현업에 도움이 되나요?
# 조금은 된다 -> 디버깅하는게 확실히 빠르다 / 구현 능력이 좋다
# 그 외에는 현업 지식이 더 도움된다
# 기본기는 어떻게 다지죠?
# 가벼운 문제를 많이 풀면서 숙달될 정도로 연습해야 함

# 보통 프로세스
# 문제 이해 -> 설계 -> 구현 -> 디버깅

# 문제 이해
# 한 문장도 이해 못한 문장이 없게끔 반복해서 읽어서라도 이해해야 함
# 이해하지 못하는 문제를 푼다는 것은 위험한 일이다
# N 값이 얼마인지, 입/출력 데이터가 만들어지는 과정을 손으로 검증
# 여기서 검증한 과정을 추후 설계 이후의 시뮬레이션에서 활용하게 된다

# 설계 -> 계획
# 다른 사람들이 바로 코딩 시작한다고 나도 흔들리면 안된다
# 종이에 손코딩하는게 아님!! 디테일하게 계획한다면 그렇게 할 수도 있지만 그럴 필요까지는 없다
# 내가 구현하려는 것을 적어두자
# 내가 어떻게 문제를 풀지 계획을 세우는 단계
# 바로 코딩(구현)으로 들어가면 하다가 아닌거같으면 바꾸고, 고치고.. 코드는 엉망이 되어간다
# 바로 풀리면 다행이지만 그 외의 경우는 전부 고생하게 된다
# 문제를 푸는 데 주어지는 전체 시간에서 많은 비중을 차지하더라도 설계는 그만큼의 가치가 있다
# 한 문제에 1시간 반이라 치면 적어도 30분정도는 설계에 투자할만하다
# 설계가 제대로 되느냐에 따라 그 문제를 풀 수 있는가 없는가가 결정된다
# 작은 문제도 설계할 수 없다면 큰 문제 역시 못하는건 자명하다
# 습관적으로 설계하자

# 설계 이후에는 시뮬레이션
# 예제 입력 데이터를 내가 설계한 계획에 따라 처리했을 때 예제의 출력 데이터와 동일하게 나오나?
# 앞서 이해 단계에서 검증한 데이터를 토대로 확인하기

# 빅오표기법
# P.S -> 반복횟수 1억당 1초
# 문제 안에서 연산횟수가 얼마나 될까? 생각해보고 시간 제한을 보면 어느 정도 유추가 된다
# 문제 이해 단계에서 N값을 꼭 보자
# N값을 생각해보면 반복문의 경우 몇중 for까지 허용될지 계산이 된다
# N값이 2 ~ 30정도이면 DFS일 가능성을 의심해보자
# 2차원 배열에 N값이 10 ~ 100정도라면 BFS를 생각해보자
# N이 1000단위라면 2중 for에 DP를 의심할 수 있음
# N이 10만 단위라면 1중 for에 무언가 규칙이 있을 것이라는 추론이 가능(그리디, DP)
# 2중 for 돌리는 순간 터지겠구나라고 생각이 들어야 함
# O(log N)은 O(1)과 비슷 -> 빠른 알고리즘

# 설계 실습 순서
# 절차적 설계
# 순서를 나눠서 무엇을 하고, 그 다음에 무엇을 할지 설계한 뒤 구현
# 한 단계 구현이 끝날 때마다 제대로 구현했는지 테스트
# 절차적 설계가 안되는 경우(주로 n중 for문) -> 세부 설계
# 세부 설계
# 몇중 for인지, 어떤 내용이 들어가야 하는지, 무엇을 할지
# 재귀 설계
# 보통 시험장에서는 스택의 사이즈가 2mb 내외로 정해진 경우가 많음
# int가 4byte라면 한 지역변수에서 만들 수 있는 배열의 사이즈는 50만개 정도
# 하지만 다른 변수들도 크기에 들어가기에 10만개쯤 넘으면 런타임 에러나 스택 오버플로등의 위험
# DFS 설계
# 기본기가 튼튼해야!-> 완전 탐색으로의 DFS
# 그 후엔 트리와 그래프도 능숙하게 DFS가 될 때까지 연습
# 경로 찾기, 길 하나 찾기, 백트래킹도 연습
# 백트래킹: 가지치기 조건을 확실하게 
# 기본기가 잘 되어있다면 응용 단계도 수월하고, 거기서 능력치가 많이 오름
# 인자 값이 무엇이 들어갈지 미리 생각을 해두자
# BFS 설계
# 2차원 배열에서 점점 퍼짐 / 그래프를 BFS식으로 탐색 완전 탐색처럼 모든 경로를 다 탐색
# 대체로 코드들이 비슷 -> 기본 코드들에서 크게 벗어나지 않는다
# 기본 틀에서 어떤 정보가 추가로 필요한지 설계 단계에서 정리

# 구현
# 문제 이해 과정, 설계에서의 시뮬레이션 과정에서 정리한 내용을 그대로 구현

# 디버깅
# 버그를 찾아내고 수정하면서도 시간을 아껴야 한다
# 한번에 다 실행하면 어느 순간 동작이 잘못된건지 알기 힘들다
# trace 기능을 사용해 한 줄씩 돌리면 어디에서 잘못됬는지 알 수가 있다
# 설계와 맞지 않게 동작이 잘못된 부분이 나온다면 그 코드가 잘못된 것
# 계속 breakpoint 범위를 좁혀가면서 문제가 생긴 구간을 찾아내기도 함
# breakpointer / step over-into / resume 등 단축키 숙지해두기(시간 절약을 위해)
# 맞왜틀? (맞는거같은데 왜 틀린거죠?)
# 재현 data를 찾아야 한다(여러 데이터, 또는 말도 안되는 데이터를 넣어보면서 디버깅)
# 재현 data? -> 원본 데이터하고는 값이 다르지만 원본 데이터 전체의 확률분포를 비교적 정밀하게 보존한 자료(원본과 최대한 유사한 통계적 성질을 가짐)
# 재현 data를 찾았다면 더 작은 데이터 중 재현 data가 있는지 찾아보자(디버깅 속도 향상)
# 정 노답이다 하면 코드 리뷰를 해야 하는데 너무 시간이 오래 걸릴 수 있는 방법 - 최후의 선택
# DP 디버깅 - 샘플 데이터가 필요
# DP -> 기존 데이터로 새 데이터를 만든다
# 조건이 빠진 경우 등으로 인해 어느 순간 오류가 나는 지점이 있다
# 디버깅을 하며 trace한 과정과 설계한 과정을 대조해보자
```

